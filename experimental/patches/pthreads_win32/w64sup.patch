Index: pthreads/GNUmakefile
===================================================================
--- pthreads.orig/GNUmakefile
+++ pthreads/GNUmakefile
@@ -58,12 +58,12 @@ CXX     = $(CROSS)g++
 RANLIB  = $(CROSS)ranlib
 RC	= $(CROSS)windres
 
-OPT	= $(CLEANUP) -O3 -finline-functions
+OPT	= $(CLEANUP) -O3  -DHAVE_STRUCT_TIMESPEC -D__MINGW32__ -finline-functions
 DOPT	= $(CLEANUP) -g -O0
 XOPT	=
 
 RCFLAGS		= --include-dir=.
-LFLAGS		= -lwsock32
+LFLAGS		= -lws2_32
 
 # ----------------------------------------------------------------------
 # The library can be built with some alternative behaviour to
Index: pthreads/tests/GNUmakefile
===================================================================
--- pthreads.orig/tests/GNUmakefile
+++ pthreads/tests/GNUmakefile
@@ -51,7 +51,7 @@ MAKE	= make
 #
 XXCFLAGS	= 
 XXLIBS	= -lws2_32
-#CFLAGS	= -O3 -UNDEBUG -Wall $(XXCFLAGS)
+#CFLAGS	= -O3 -D_M_AMD64 -UNDEBUG -Wall $(XXCFLAGS)
 CFLAGS	= -g -UNDEBUG -Wall $(XXCFLAGS)
 BUILD_DIR	= ..
 INCLUDES	= -I.
@@ -69,7 +69,7 @@ LIB	= libpthread$(GCX).a
 DLL	= pthread$(GCX).dll
 QAPC	= ../QueueUserAPCEx/User/quserex.dll
 
-COPYFILES	= $(HDR) $(LIB) $(DLL) $(QAPC)
+COPYFILES	= $(HDR) $(LIB) $(DLL)
 
 # If a test case returns a non-zero exit code to the shell, make will
 # stop.
@@ -136,7 +136,7 @@ all:
 	@ $(MAKE) clean GCE
 
 GC:
-	$(MAKE) TEST=GC CC=gcc XXCFLAGS="-D__CLEANUP_C" all-pass
+	$(MAKE) TEST=GC CC=x86_64-pc-mingw32-gcc XXCFLAGS="-D__CLEANUP_C" all-pass
 
 GCE:
 	$(MAKE) TEST=GCE CC=g++ XXCFLAGS="-mthreads -D__CLEANUP_CXX" all-pass
@@ -316,24 +316,24 @@ valid2.pass: valid1.pass
 
 sizes.pass: sizes.exe
 	@ $(ECHO) Running $*
-	$< > SIZES.$(TEST)
+	./$< > SIZES.$(TEST)
 	@ $(CAT) SIZES.$(TEST)
 	@ $(ECHO) Passed
 	@ $(TOUCH) $@
 
 %.pass: %.exe
 	@ $(ECHO) Running $*
-	$*
+	./$*
 	@ $(ECHO) Passed
 	@ $(TOUCH) $@
 
-%.bench: $(LIB) $(DLL) $(HDR) $(QAPC) $(XXLIBS) %.exe
+%.bench: $(LIB) $(DLL) $(HDR)  $(XXLIBS) %.exe
 	@ $(ECHO) Running $*
 	$*
 	@ $(ECHO) Done
 	@ $(TOUCH) $@
 
-%.exe: %.c $(LIB) $(DLL) $(HDR) $(QAPC)
+%.exe: %.c $(LIB) $(DLL) $(HDR)
 	@ $(ECHO) Compiling $@
 	@ $(ECHO) $(CC) $(CFLAGS) -o $@ $< $(INCLUDES) -L. -lpthread$(GCX) -lsupc++ $(XXLIBS)
 	@ $(CC) $(CFLAGS) -o $@ $< $(INCLUDES) -L. -lpthread$(GCX) -lsupc++ $(XXLIBS)
Index: pthreads/tests/barrier3.c
===================================================================
--- pthreads.orig/tests/barrier3.c
+++ pthreads/tests/barrier3.c
@@ -41,7 +41,7 @@
 #include "test.h"
  
 pthread_barrier_t barrier = NULL;
-static int result = 1;
+static DWORD_PTR result = 1;
 
 void * func(void * arg)
 {
Index: pthreads/tests/cancel2.c
===================================================================
--- pthreads.orig/tests/cancel2.c
+++ pthreads/tests/cancel2.c
@@ -217,7 +217,7 @@ main()
   for (i = 1; i <= NUMTHREADS; i++)
     {
       int fail = 0;
-      int result = 0;
+      DWORD_PTR result = 0;
 
       assert(pthread_join(t[i], (void **) &result) == 0);
       fail = (result != (int) PTHREAD_CANCELED);
Index: pthreads/tests/cancel3.c
===================================================================
--- pthreads.orig/tests/cancel3.c
+++ pthreads/tests/cancel3.c
@@ -173,7 +173,7 @@ main ()
   for (i = 1; i <= NUMTHREADS; i++)
     {
       int fail = 0;
-      int result = 0;
+      DWORD_PTR result = 0;
 
       /*
        * The thread does not contain any cancelation points, so
Index: pthreads/tests/cancel4.c
===================================================================
--- pthreads.orig/tests/cancel4.c
+++ pthreads/tests/cancel4.c
@@ -98,7 +98,7 @@ static bag_t threadbag[NUMTHREADS + 1];
 void *
 mythread(void * arg)
 {
-  int result = ((int)PTHREAD_CANCELED + 1);
+  int result = ((int)(size_t)PTHREAD_CANCELED + 1);
   bag_t * bag = (bag_t *) arg;
 
   assert(bag == &threadbag[bag->threadnum]);
@@ -118,7 +118,7 @@ mythread(void * arg)
   for (bag->count = 0; bag->count < 20; bag->count++)
     Sleep(100);
 
-  return (void *) result;
+  return (void *) (size_t)result;
 }
 
 int
@@ -173,7 +173,7 @@ main()
   for (i = 1; i <= NUMTHREADS; i++)
     {
       int fail = 0;
-      int result = 0;
+      DWORD_PTR result = 0;
 
       /*
        * The thread does not contain any cancelation points, so
@@ -182,7 +182,7 @@ main()
        */
       assert(pthread_join(t[i], (void **) &result) == 0);
 
-      fail = (result == (int) PTHREAD_CANCELED);
+      fail = (result == (int) (size_t) PTHREAD_CANCELED);
 
       if (fail)
 	{
Index: pthreads/tests/cancel5.c
===================================================================
--- pthreads.orig/tests/cancel5.c
+++ pthreads/tests/cancel5.c
@@ -171,7 +171,7 @@ main ()
   for (i = 1; i <= NUMTHREADS; i++)
     {
       int fail = 0;
-      int result = 0;
+      DWORD_PTR result = 0;
 
       /*
        * The thread does not contain any cancelation points, so
Index: pthreads/tests/cancel6a.c
===================================================================
--- pthreads.orig/tests/cancel6a.c
+++ pthreads/tests/cancel6a.c
@@ -85,7 +85,7 @@ static bag_t threadbag[NUMTHREADS + 1];
 void *
 mythread(void * arg)
 {
-  int result = ((int)PTHREAD_CANCELED + 1);
+  int result = ((int)(size_t)PTHREAD_CANCELED + 1);
   bag_t * bag = (bag_t *) arg;
 
   assert(bag == &threadbag[bag->threadnum]);
@@ -105,7 +105,7 @@ mythread(void * arg)
   for (bag->count = 0; bag->count < 100; bag->count++)
     Sleep(100);
 
-  return (void *) result;
+  return (void *) (size_t)result;
 }
 
 int
@@ -161,7 +161,7 @@ main()
   for (i = 1; i <= NUMTHREADS; i++)
     {
       int fail = 0;
-      int result = 0;
+      DWORD_PTR result = 0;
 
       /*
        * The thread does not contain any cancelation points, so
@@ -170,7 +170,7 @@ main()
        */
       assert(pthread_join(t[i], (void **) &result) == 0);
 
-      fail = (result != (int) PTHREAD_CANCELED);
+      fail = (result != (int) (size_t) PTHREAD_CANCELED);
 
       if (fail)
 	{
Index: pthreads/tests/cancel6d.c
===================================================================
--- pthreads.orig/tests/cancel6d.c
+++ pthreads/tests/cancel6d.c
@@ -86,7 +86,7 @@ static bag_t threadbag[NUMTHREADS + 1];
 void *
 mythread(void * arg)
 {
-  int result = ((int)PTHREAD_CANCELED + 1);
+  int result = ((int) (size_t) PTHREAD_CANCELED + 1);
   bag_t * bag = (bag_t *) arg;
 
   assert(bag == &threadbag[bag->threadnum]);
@@ -109,7 +109,7 @@ mythread(void * arg)
       pthread_testcancel();
     }
 
-  return (void *) result;
+  return (void *) (size_t) result;
 }
 
 int
@@ -165,11 +165,11 @@ main()
   for (i = 1; i <= NUMTHREADS; i++)
     {
       int fail = 0;
-      int result = 0;
+      DWORD_PTR result = 0;
 
       assert(pthread_join(t[i], (void **) &result) == 0);
 
-      fail = (result != (int) PTHREAD_CANCELED);
+      fail = (result != (int) (size_t) PTHREAD_CANCELED);
 
       if (fail)
 	{
Index: pthreads/tests/cleanup0.c
===================================================================
--- pthreads.orig/tests/cleanup0.c
+++ pthreads/tests/cleanup0.c
@@ -189,7 +189,7 @@ main()
   for (i = 1; i <= NUMTHREADS; i++)
     {
       int fail = 0;
-      int result = 0;
+      DWORD_PTR result = 0;
 
       assert(pthread_join(t[i], (void **) &result) == 0);
 
Index: pthreads/tests/cleanup1.c
===================================================================
--- pthreads.orig/tests/cleanup1.c
+++ pthreads/tests/cleanup1.c
@@ -203,7 +203,7 @@ main()
   for (i = 1; i <= NUMTHREADS; i++)
     {
       int fail = 0;
-      int result = 0;
+      DWORD_PTR result = 0;
 
       assert(pthread_join(t[i], (void **) &result) == 0);
 
Index: pthreads/tests/cleanup2.c
===================================================================
--- pthreads.orig/tests/cleanup2.c
+++ pthreads/tests/cleanup2.c
@@ -178,7 +178,7 @@ main()
   for (i = 1; i <= NUMTHREADS; i++)
     {
       int fail = 0;
-      int result = 0;
+      DWORD_PTR result = 0;
 
       assert(pthread_join(t[i], (void **) &result) == 0);
 
Index: pthreads/tests/cleanup3.c
===================================================================
--- pthreads.orig/tests/cleanup3.c
+++ pthreads/tests/cleanup3.c
@@ -183,7 +183,7 @@ main()
   for (i = 1; i <= NUMTHREADS; i++)
     {
       int fail = 0;
-      int result = 0;
+      DWORD_PTR result = 0;
 
       assert(pthread_join(t[i], (void **) &result) == 0);
 
Index: pthreads/tests/condvar1_2.c
===================================================================
--- pthreads.orig/tests/condvar1_2.c
+++ pthreads/tests/condvar1_2.c
@@ -89,7 +89,7 @@ int
 main()
 {
   int i, j, k;
-  int result = -1;
+  DWORD_PTR result = -1;
   pthread_t t;
 
   for (k = 0; k < NUM_LOOPS; k++)
Index: pthreads/tests/condvar2.c
===================================================================
--- pthreads.orig/tests/condvar2.c
+++ pthreads/tests/condvar2.c
@@ -99,7 +99,7 @@ main()
   /* get current system time */
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 1;
@@ -109,7 +109,7 @@ main()
   assert(pthread_mutex_unlock(&mutex) == 0);
 
   {
-  int result = pthread_cond_destroy(&cv);
+  DWORD_PTR result = pthread_cond_destroy(&cv);
   if (result != 0)
     {
       fprintf(stderr, "Result = %s\n", error_string[result]);
Index: pthreads/tests/condvar2_1.c
===================================================================
--- pthreads.orig/tests/condvar2_1.c
+++ pthreads/tests/condvar2_1.c
@@ -105,7 +105,7 @@ main()
 {
   int i;
   pthread_t t[NUMTHREADS + 1];
-  int result = 0;
+  DWORD_PTR result = 0;
   struct _timeb currSysTime;
   const DWORD NANOSEC_PER_MILLISEC = 1000000;
 
@@ -116,7 +116,7 @@ main()
   /* get current system time */
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 5;
Index: pthreads/tests/condvar3.c
===================================================================
--- pthreads.orig/tests/condvar3.c
+++ pthreads/tests/condvar3.c
@@ -126,7 +126,7 @@ main()
   /* get current system time */
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   assert(pthread_create(&t[1], NULL, mythread, (void *) 1) == 0);
Index: pthreads/tests/condvar3_1.c
===================================================================
--- pthreads.orig/tests/condvar3_1.c
+++ pthreads/tests/condvar3_1.c
@@ -126,7 +126,7 @@ main()
 {
   int i;
   pthread_t t[NUMTHREADS + 1];
-  int result = 0;
+  DWORD_PTR result = 0;
   struct _timeb currSysTime;
   const DWORD NANOSEC_PER_MILLISEC = 1000000;
 
@@ -139,7 +139,7 @@ main()
   /* get current system time */
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 5;
Index: pthreads/tests/condvar3_2.c
===================================================================
--- pthreads.orig/tests/condvar3_2.c
+++ pthreads/tests/condvar3_2.c
@@ -127,7 +127,7 @@ main()
 {
   int i;
   pthread_t t[NUMTHREADS + 1];
-  int result = 0;
+  DWORD_PTR result = 0;
   struct _timeb currSysTime;
   const DWORD NANOSEC_PER_MILLISEC = 1000000;
 
@@ -138,7 +138,7 @@ main()
   /* get current system time */
   _ftime(&currSysTime);
 
-  abstime.tv_sec = abstime.tv_sec = currSysTime.time + 5;
+  abstime.tv_sec = abstime.tv_sec = (long)currSysTime.time + 5;
   abstime.tv_nsec = abstime2.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   assert(pthread_mutex_lock(&mutex) == 0);
Index: pthreads/tests/condvar3_3.c
===================================================================
--- pthreads.orig/tests/condvar3_3.c
+++ pthreads/tests/condvar3_3.c
@@ -96,7 +96,7 @@ int main()
    /* get current system time */
    _ftime(&currSysTime);
 
-   abstime.tv_sec = currSysTime.time;
+   abstime.tv_sec = (long)currSysTime.time;
    abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
    abstime.tv_sec += 1;
 
@@ -120,7 +120,7 @@ int main()
 
    assert(pthread_mutex_lock(&mtx) == 0);
 
-   abstime.tv_sec = currSysTime.time;
+   abstime.tv_sec = (long)currSysTime.time;
    abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
    abstime.tv_sec += 1;
 
Index: pthreads/tests/condvar4.c
===================================================================
--- pthreads.orig/tests/condvar4.c
+++ pthreads/tests/condvar4.c
@@ -130,7 +130,7 @@ main()
   /* get current system time */
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 5;
@@ -143,7 +143,7 @@ main()
 
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 5;
Index: pthreads/tests/condvar5.c
===================================================================
--- pthreads.orig/tests/condvar5.c
+++ pthreads/tests/condvar5.c
@@ -129,7 +129,7 @@ main()
   /* get current system time */
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 5;
@@ -142,7 +142,7 @@ main()
 
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 5;
Index: pthreads/tests/condvar6.c
===================================================================
--- pthreads.orig/tests/condvar6.c
+++ pthreads/tests/condvar6.c
@@ -159,7 +159,7 @@ main()
 
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 5;
Index: pthreads/tests/condvar7.c
===================================================================
--- pthreads.orig/tests/condvar7.c
+++ pthreads/tests/condvar7.c
@@ -169,7 +169,7 @@ main()
 
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 10;
Index: pthreads/tests/condvar8.c
===================================================================
--- pthreads.orig/tests/condvar8.c
+++ pthreads/tests/condvar8.c
@@ -166,7 +166,7 @@ main()
 
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 10;
Index: pthreads/tests/condvar9.c
===================================================================
--- pthreads.orig/tests/condvar9.c
+++ pthreads/tests/condvar9.c
@@ -174,7 +174,7 @@ main()
 
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 5;
Index: pthreads/tests/delay2.c
===================================================================
--- pthreads.orig/tests/delay2.c
+++ pthreads/tests/delay2.c
@@ -65,7 +65,7 @@ int
 main(int argc, char * argv[])
 {
   pthread_t t;
-  int result = 0;
+  DWORD_PTR result = 0;
 
   assert(pthread_mutex_lock(&mx) == 0);
 
Index: pthreads/tests/exception1.c
===================================================================
--- pthreads.orig/tests/exception1.c
+++ pthreads/tests/exception1.c
@@ -226,7 +226,7 @@ main()
   for (i = 0; i < NUMTHREADS; i++)
     {
       int fail = 0;
-      int result = 0;
+      DWORD_PTR result = 0;
 
 	/* Canceled thread */
       assert(pthread_join(ct[i], (void **) &result) == 0);
Index: pthreads/tests/join0.c
===================================================================
--- pthreads.orig/tests/join0.c
+++ pthreads/tests/join0.c
@@ -53,7 +53,7 @@ int
 main(int argc, char * argv[])
 {
   pthread_t id;
-  int result;
+  DWORD_PTR result;
 
   /* Create a single thread and wait for it to exit. */
   assert(pthread_create(&id, NULL, func, (void *) 123) == 0);
Index: pthreads/tests/join1.c
===================================================================
--- pthreads.orig/tests/join1.c
+++ pthreads/tests/join1.c
@@ -56,7 +56,7 @@ main(int argc, char * argv[])
 {
 	pthread_t id[4];
 	int i;
-	int result;
+	DWORD_PTR result;
 
 	/* Create a few threads and then exit. */
 	for (i = 0; i < 4; i++)
Index: pthreads/tests/join2.c
===================================================================
--- pthreads.orig/tests/join2.c
+++ pthreads/tests/join2.c
@@ -50,7 +50,7 @@ main(int argc, char * argv[])
 {
 	pthread_t id[4];
 	int i;
-	int result;
+	DWORD_PTR result;
 
 	/* Create a few threads and then exit. */
 	for (i = 0; i < 4; i++)
Index: pthreads/tests/join3.c
===================================================================
--- pthreads.orig/tests/join3.c
+++ pthreads/tests/join3.c
@@ -50,7 +50,7 @@ main(int argc, char * argv[])
 {
 	pthread_t id[4];
 	int i;
-	int result;
+	DWORD_PTR result;
 
 	/* Create a few threads and then exit. */
 	for (i = 0; i < 4; i++)
Index: pthreads/tests/mutex6e.c
===================================================================
--- pthreads.orig/tests/mutex6e.c
+++ pthreads/tests/mutex6e.c
@@ -74,7 +74,7 @@ int
 main()
 {
   pthread_t t;
-  int result = 0;
+  DWORD_PTR result = 0;
   int mxType = -1;
 
   assert(pthread_mutexattr_init(&mxAttr) == 0);
Index: pthreads/tests/mutex6es.c
===================================================================
--- pthreads.orig/tests/mutex6es.c
+++ pthreads/tests/mutex6es.c
@@ -73,7 +73,7 @@ int
 main()
 {
   pthread_t t;
-  int result = 0;
+  DWORD_PTR result = 0;
 
   assert(mutex == PTHREAD_ERRORCHECK_MUTEX_INITIALIZER);
 
Index: pthreads/tests/mutex6r.c
===================================================================
--- pthreads.orig/tests/mutex6r.c
+++ pthreads/tests/mutex6r.c
@@ -73,7 +73,7 @@ int
 main()
 {
   pthread_t t;
-  int result = 0;
+  DWORD_PTR result = 0;
   int mxType = -1;
 
   assert(pthread_mutexattr_init(&mxAttr) == 0);
Index: pthreads/tests/mutex6rs.c
===================================================================
--- pthreads.orig/tests/mutex6rs.c
+++ pthreads/tests/mutex6rs.c
@@ -72,7 +72,7 @@ int
 main()
 {
   pthread_t t;
-  int result = 0;
+  DWORD_PTR result = 0;
 
   assert(mutex == PTHREAD_RECURSIVE_MUTEX_INITIALIZER);
 
Index: pthreads/tests/mutex7e.c
===================================================================
--- pthreads.orig/tests/mutex7e.c
+++ pthreads/tests/mutex7e.c
@@ -74,7 +74,7 @@ int
 main()
 {
   pthread_t t;
-  int result = 0;
+  DWORD_PTR result = 0;
   int mxType = -1;
 
   assert(pthread_mutexattr_init(&mxAttr) == 0);
Index: pthreads/tests/mutex7r.c
===================================================================
--- pthreads.orig/tests/mutex7r.c
+++ pthreads/tests/mutex7r.c
@@ -73,7 +73,7 @@ int
 main()
 {
   pthread_t t;
-  int result = 0;
+  DWORD_PTR result = 0;
   int mxType = -1;
 
   assert(pthread_mutexattr_init(&mxAttr) == 0);
Index: pthreads/tests/mutex8.c
===================================================================
--- pthreads.orig/tests/mutex8.c
+++ pthreads/tests/mutex8.c
@@ -49,7 +49,7 @@ void * locker(void * arg)
 
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 1;
Index: pthreads/tests/mutex8e.c
===================================================================
--- pthreads.orig/tests/mutex8e.c
+++ pthreads/tests/mutex8e.c
@@ -57,7 +57,7 @@ void * locker(void * arg)
 
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 1;
Index: pthreads/tests/mutex8n.c
===================================================================
--- pthreads.orig/tests/mutex8n.c
+++ pthreads/tests/mutex8n.c
@@ -57,7 +57,7 @@ void * locker(void * arg)
 
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 1;
Index: pthreads/tests/mutex8r.c
===================================================================
--- pthreads.orig/tests/mutex8r.c
+++ pthreads/tests/mutex8r.c
@@ -57,7 +57,7 @@ void * locker(void * arg)
 
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 1;
Index: pthreads/tests/rwlock2_t.c
===================================================================
--- pthreads.orig/tests/rwlock2_t.c
+++ pthreads/tests/rwlock2_t.c
@@ -55,7 +55,7 @@ main()
 
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 1;
Index: pthreads/tests/rwlock3_t.c
===================================================================
--- pthreads.orig/tests/rwlock3_t.c
+++ pthreads/tests/rwlock3_t.c
@@ -68,7 +68,7 @@ main()
 
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 1;
Index: pthreads/tests/rwlock4_t.c
===================================================================
--- pthreads.orig/tests/rwlock4_t.c
+++ pthreads/tests/rwlock4_t.c
@@ -68,7 +68,7 @@ main()
 
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 1;
Index: pthreads/tests/rwlock5_t.c
===================================================================
--- pthreads.orig/tests/rwlock5_t.c
+++ pthreads/tests/rwlock5_t.c
@@ -70,7 +70,7 @@ main()
 
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 1;
Index: pthreads/tests/rwlock6.c
===================================================================
--- pthreads.orig/tests/rwlock6.c
+++ pthreads/tests/rwlock6.c
@@ -77,9 +77,9 @@ main()
   pthread_t wrt1;
   pthread_t wrt2;
   pthread_t rdt;
-  int wr1Result = 0;
-  int wr2Result = 0;
-  int rdResult = 0;
+  DWORD_PTR wr1Result = 0;
+  DWORD_PTR wr2Result = 0;
+  DWORD_PTR rdResult = 0;
 
   bankAccount = 0;
 
Index: pthreads/tests/rwlock6_t.c
===================================================================
--- pthreads.orig/tests/rwlock6_t.c
+++ pthreads/tests/rwlock6_t.c
@@ -55,7 +55,7 @@ void * wrfunc(void * arg)
   bankAccount += 10;
   assert(pthread_rwlock_unlock(&rwlock1) == 0);
 
-  return ((void *) bankAccount);
+  return ((void *) (size_t) bankAccount);
 }
 
 void * rdfunc(void * arg)
@@ -67,17 +67,17 @@ void * rdfunc(void * arg)
 
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
 
-  if ((int) arg == 1)
+  if ((int) ((size_t) arg) == 1)
     {
       abstime.tv_sec += 1;
       assert(pthread_rwlock_timedrdlock(&rwlock1, &abstime) == ETIMEDOUT);
       ba = 0;
     }
-  else if ((int) arg == 2)
+  else if ((int) ((size_t) arg) == 2)
     {
       abstime.tv_sec += 3;
       assert(pthread_rwlock_timedrdlock(&rwlock1, &abstime) == 0);
@@ -85,7 +85,7 @@ void * rdfunc(void * arg)
       assert(pthread_rwlock_unlock(&rwlock1) == 0);
     }
 
-  return ((void *) ba);
+  return ((void *) (size_t) ba);
 }
 
 int
@@ -95,10 +95,10 @@ main()
   pthread_t wrt2;
   pthread_t rdt1;
   pthread_t rdt2;
-  int wr1Result = 0;
-  int wr2Result = 0;
-  int rd1Result = 0;
-  int rd2Result = 0;
+  DWORD_PTR wr1Result = 0;
+  DWORD_PTR wr2Result = 0;
+  DWORD_PTR rd1Result = 0;
+  DWORD_PTR rd2Result = 0;
 
   bankAccount = 0;
 
Index: pthreads/tests/rwlock6_t2.c
===================================================================
--- pthreads.orig/tests/rwlock6_t2.c
+++ pthreads/tests/rwlock6_t2.c
@@ -54,21 +54,21 @@ void * wrfunc(void * arg)
   int result;
 
   result = pthread_rwlock_timedwrlock(&rwlock1, &abstime);
-  if ((int) arg == 1)
+  if ((int) ((size_t)arg) == 1)
     {
       assert(result == 0);
       Sleep(2000);
       bankAccount += 10;
       assert(pthread_rwlock_unlock(&rwlock1) == 0);
-      return ((void *) bankAccount);
+      return ((void *) (size_t) bankAccount);
     }
-  else if ((int) arg == 2)
+  else if ((int) ((size_t)arg) == 2)
     {
       assert(result == ETIMEDOUT);
-      return ((void *) 100);
+      return ((void *) (size_t) 100);
     }
 
-  return ((void *) -1);
+  return ((void *) (size_t) -1);
 }
 
 void * rdfunc(void * arg)
@@ -77,7 +77,7 @@ void * rdfunc(void * arg)
 
   assert(pthread_rwlock_timedrdlock(&rwlock1, &abstime) == ETIMEDOUT);
 
-  return ((void *) ba);
+  return ((void *) (size_t) ba);
 }
 
 int
@@ -86,15 +86,15 @@ main()
   pthread_t wrt1;
   pthread_t wrt2;
   pthread_t rdt;
-  int wr1Result = 0;
-  int wr2Result = 0;
-  int rdResult = 0;
+  DWORD_PTR wr1Result = 0;
+  DWORD_PTR wr2Result = 0;
+  DWORD_PTR rdResult = 0;
   struct _timeb currSysTime;
   const DWORD NANOSEC_PER_MILLISEC = 1000000;
 
   _ftime(&currSysTime);
 
-  abstime.tv_sec = currSysTime.time;
+  abstime.tv_sec = (long)currSysTime.time;
   abstime.tv_nsec = NANOSEC_PER_MILLISEC * currSysTime.millitm;
 
   abstime.tv_sec += 1;
Index: pthreads/tests/semaphore1.c
===================================================================
--- pthreads.orig/tests/semaphore1.c
+++ pthreads/tests/semaphore1.c
@@ -119,7 +119,7 @@ main()
 {
   pthread_t t;
   sem_t s;
-  int result;
+  DWORD_PTR result;
 
   assert(pthread_create(&t, NULL, thr, NULL) == 0);
   assert(pthread_join(t, (void **)&result) == 0);
Index: pthreads/tests/semaphore4.c
===================================================================
--- pthreads.orig/tests/semaphore4.c
+++ pthreads/tests/semaphore4.c
@@ -113,7 +113,7 @@ main()
 //printf("value = %d\n", -value); fflush(stdout);
 	assert(pthread_cancel(t[50]) == 0);
 	  {
-	    int result;
+	    DWORD_PTR result;
 	    assert(pthread_join(t[50], (void **) &result) == 0);
 //	    printf("result = %d\n", result); fflush(stdout);
 	  }
Index: pthreads/tests/spin4.c
===================================================================
--- pthreads.orig/tests/spin4.c
+++ pthreads/tests/spin4.c
@@ -63,7 +63,7 @@ void * func(void * arg)
 int
 main()
 {
-  long result = 0;
+  DWORD_PTR result = 0;
   pthread_t t;
   int CPUs;
   struct _timeb sysTime;
Index: pthreads/tests/tsd1.c
===================================================================
--- pthreads.orig/tests/tsd1.c
+++ pthreads/tests/tsd1.c
@@ -179,7 +179,7 @@ main()
    */
   for (i = 1; i < NUM_THREADS; i++)
     {
-	int result = 0;
+	DWORD_PTR result = 0;
 
 	assert(pthread_join(thread[i], (void **) &result) == 0);
     }
Index: pthreads/tests/tsd2.c
===================================================================
--- pthreads.orig/tests/tsd2.c
+++ pthreads/tests/tsd2.c
@@ -183,7 +183,7 @@ main()
    */
   for (i = 1; i < NUM_THREADS; i++)
     {
-	int result = 0;
+	DWORD_PTR result = 0;
 
 	assert(pthread_join(thread[i], (void **) &result) == 0);
     }
Index: pthreads/version.rc
===================================================================
--- pthreads.orig/version.rc
+++ pthreads/version.rc
@@ -58,10 +58,10 @@
 #elif defined(__GNUC__)
 #  if defined(__CLEANUP_C)
 #    define PTW32_VERSIONINFO_NAME "pthreadGC\0"
-#    define PTW32_VERSIONINFO_COMMENT "GNU C build -- longjmp thread exiting\0"
+#    define PTW32_VERSIONINFO_COMMENT "GNU C build bit -- longjmp thread exiting\0"
 #  elif defined(__CLEANUP_CXX)
 #    define PTW32_VERSIONINFO_NAME "pthreadGCE\0"
-#    define PTW32_VERSIONINFO_COMMENT "GNU C++ build -- C++ exception thread exiting\0"
+#    define PTW32_VERSIONINFO_COMMENT "GNU C++ build bit -- C++ exception thread exiting\0"
 #  else
 #    error Resource compiler doesn't know which cleanup style you're using - see version.rc
 #  endif
@@ -102,7 +102,7 @@ BEGIN
     BEGIN
         BLOCK "040904b0"
         BEGIN
-            VALUE "FileDescription", "POSIX Threads for Windows32 Library\0"
+            VALUE "FileDescription", "POSIX Threads for Windows Library\0"
             VALUE "ProductVersion", PTW32_VERSION_STRING
             VALUE "FileVersion", PTW32_VERSION_STRING
             VALUE "InternalName", PTW32_VERSIONINFO_NAME
Index: pthreads/pthread.h
===================================================================
--- pthreads.orig/pthread.h
+++ pthreads/pthread.h
@@ -304,10 +304,13 @@ enum {
 
 #ifndef HAVE_STRUCT_TIMESPEC
 #define HAVE_STRUCT_TIMESPEC 1
+#ifndef _TIMESPEC_DEFINED
+#define _TIMESPEC_DEFINED
 struct timespec {
         time_t tv_sec;
         long tv_nsec;
 };
+#endif
 #endif /* HAVE_STRUCT_TIMESPEC */
 
 #ifndef SIG_BLOCK
Index: pthreads/pthread_cancel.c
===================================================================
--- pthreads.orig/pthread_cancel.c
+++ pthreads/pthread_cancel.c
@@ -165,7 +165,7 @@ pthread_cancel (pthread_t thread)
 	       * this will result in a call to ptw32_RegisterCancelation and only
 	       * the threadH arg will be used.
 	       */
-	      ptw32_register_cancelation (ptw32_cancel_callback, threadH, 0);
+	      ptw32_register_cancelation ((PAPCFUNC)ptw32_cancel_callback, threadH, 0);
 	      (void) pthread_mutex_unlock (&tp->cancelLock);
 	      ResumeThread (threadH);
 	    }
Index: pthreads/pthread_exit.c
===================================================================
--- pthreads.orig/pthread_exit.c
+++ pthreads/pthread_exit.c
@@ -89,7 +89,7 @@ pthread_exit (void *value_ptr)
        */
 
 #if ! defined (__MINGW32__) || defined (__MSVCRT__)  || defined (__DMC__)
-      _endthreadex ((unsigned) value_ptr);
+      _endthreadex ((unsigned) (size_t) value_ptr);
 #else
       _endthread ();
 #endif
Index: pthreads/pthread_spin_destroy.c
===================================================================
--- pthreads.orig/pthread_spin_destroy.c
+++ pthreads/pthread_spin_destroy.c
@@ -59,9 +59,9 @@ pthread_spin_destroy (pthread_spinlock_t
 	       PTW32_INTERLOCKED_COMPARE_EXCHANGE ((PTW32_INTERLOCKED_LPLONG)
 						   & (s->interlock),
 						   (PTW32_INTERLOCKED_LONG)
-						   PTW32_OBJECT_INVALID,
+						   (size_t)PTW32_OBJECT_INVALID,
 						   (PTW32_INTERLOCKED_LONG)
-						   PTW32_SPIN_UNLOCKED))
+						   (size_t)PTW32_SPIN_UNLOCKED))
 	{
 	  result = EINVAL;
 	}
Index: pthreads/pthread_timechange_handler_np.c
===================================================================
--- pthreads.orig/pthread_timechange_handler_np.c
+++ pthreads/pthread_timechange_handler_np.c
@@ -103,5 +103,5 @@ pthread_timechange_handler_np (void *arg
 
   LeaveCriticalSection (&ptw32_cond_list_lock);
 
-  return (void *) (result != 0 ? EAGAIN : 0);
+  return (void *) (size_t) (result != 0 ? EAGAIN : 0);
 }
Index: pthreads/ptw32_MCS_lock.c
===================================================================
--- pthreads.orig/ptw32_MCS_lock.c
+++ pthreads/ptw32_MCS_lock.c
@@ -101,10 +101,10 @@
 INLINE void 
 ptw32_mcs_flag_set (LONG * flag)
 {
-  HANDLE e = (HANDLE)PTW32_INTERLOCKED_COMPARE_EXCHANGE(
+  HANDLE e = (HANDLE)(size_t) PTW32_INTERLOCKED_COMPARE_EXCHANGE(
 						(PTW32_INTERLOCKED_LPLONG)flag,
-						(PTW32_INTERLOCKED_LONG)-1,
-						(PTW32_INTERLOCKED_LONG)0);
+						(PTW32_INTERLOCKED_LONG)(size_t)-1,
+						(PTW32_INTERLOCKED_LONG)(size_t)0);
   if ((HANDLE)0 != e)
     {
       /* another thread has already stored an event handle in the flag */
@@ -129,8 +129,8 @@ ptw32_mcs_flag_wait (LONG * flag)
 
       if (0 == PTW32_INTERLOCKED_COMPARE_EXCHANGE(
 			                  (PTW32_INTERLOCKED_LPLONG)flag,
-			                  (PTW32_INTERLOCKED_LONG)e,
-			                  (PTW32_INTERLOCKED_LONG)0))
+			                  (PTW32_INTERLOCKED_LONG)(size_t)e,
+			                  (PTW32_INTERLOCKED_LONG)(size_t)0))
 	{
 	  /* stored handle in the flag. wait on it now. */
 	  WaitForSingleObject(e, INFINITE);
@@ -159,8 +159,8 @@ ptw32_mcs_lock_acquire (ptw32_mcs_lock_t
   node->next = 0; /* initially, no successor */
   
   /* queue for the lock */
-  pred = (ptw32_mcs_local_node_t *)PTW32_INTERLOCKED_EXCHANGE((LPLONG)lock,
-						              (LONG)node);
+  pred = (ptw32_mcs_local_node_t *)InterlockedExchangePointer((PVOID volatile *)lock,
+						              (void*)node);
 
   if (0 != pred)
     {
@@ -184,16 +184,19 @@ ptw32_mcs_lock_release (ptw32_mcs_local_
 {
   ptw32_mcs_lock_t *lock = node->lock;
   ptw32_mcs_local_node_t *next = (ptw32_mcs_local_node_t *)
+#ifndef _WIN64
     InterlockedExchangeAdd((LPLONG)&node->next, 0); /* MBR fence */
-
+#else
+    InterlockedExchangeAdd64((LONG64 *)&node->next, 0); /* MBR fence */
+#endif
   if (0 == next)
     {
       /* no known successor */
 
       if (node == (ptw32_mcs_local_node_t *)
-	  PTW32_INTERLOCKED_COMPARE_EXCHANGE((PTW32_INTERLOCKED_LPLONG)lock,
-					     (PTW32_INTERLOCKED_LONG)0,
-					     (PTW32_INTERLOCKED_LONG)node))
+	  InterlockedCompareExchangePointer((LPVOID volatile *)lock,
+					     (PVOID)0,
+					     (PVOID)node))
 	{
 	  /* no successor, lock is free now */
 	  return;
@@ -202,7 +205,11 @@ ptw32_mcs_lock_release (ptw32_mcs_local_
       /* wait for successor */
       ptw32_mcs_flag_wait(&node->nextFlag);
       next = (ptw32_mcs_local_node_t *)
+#ifndef _WIN64
 	InterlockedExchangeAdd((LPLONG)&node->next, 0); /* MBR fence */
+#else
+	InterlockedExchangeAdd64((LONG64 *)&node->next, 0); /* MBR fence */
+#endif
     }
 
   /* pass the lock */
Index: pthreads/ptw32_threadStart.c
===================================================================
--- pthreads.orig/ptw32_threadStart.c
+++ pthreads/ptw32_threadStart.c
@@ -344,7 +344,7 @@ ptw32_threadStart (void *vthreadParms)
 #endif
 
 #if ! defined (__MINGW32__) || defined (__MSVCRT__) || defined (__DMC__)
-  _endthreadex ((unsigned) status);
+  _endthreadex ((unsigned) (size_t) status);
 #else
   _endthread ();
 #endif
@@ -354,7 +354,7 @@ ptw32_threadStart (void *vthreadParms)
    */
 
 #if ! defined (__MINGW32__) || defined (__MSVCRT__) || defined (__DMC__)
-  return (unsigned) status;
+  return (unsigned) (size_t) status;
 #endif
 
 }				/* ptw32_threadStart */
Index: pthreads/ptw32_throw.c
===================================================================
--- pthreads.orig/ptw32_throw.c
+++ pthreads/ptw32_throw.c
@@ -79,12 +79,12 @@ ptw32_throw (DWORD exception)
       switch (exception)
 	{
 	case PTW32_EPS_CANCEL:
-	  exitCode = (unsigned) PTHREAD_CANCELED;
+	  exitCode = (unsigned) (size_t) PTHREAD_CANCELED;
 	  break;
 	case PTW32_EPS_EXIT:
 	  if (NULL != sp)
 	    {
-	      exitCode = (unsigned) sp->exitStatus;
+	      exitCode = (unsigned) (size_t) sp->exitStatus;
 	    }
 	  break;
 	}
@@ -166,7 +166,7 @@ ptw32_get_exception_services_code (void)
 
 #else
 
-  return (DWORD) NULL;
+  return (DWORD) (size_t) NULL;
 
 #endif
 }
Index: pthreads/context.h
===================================================================
--- pthreads.orig/context.h
+++ pthreads/context.h
@@ -39,7 +39,7 @@
 
 #undef PTW32_PROGCTR
 
-#if defined(_M_IX86) || defined(_X86_)
+#if defined(_M_IX86) || (defined(_X86_) && !defined(__amd64__))
 #define PTW32_PROGCTR(Context)  ((Context).Eip)
 #endif
 
Index: pthreads/tests/barrier5.c
===================================================================
--- pthreads.orig/tests/barrier5.c
+++ pthreads/tests/barrier5.c
@@ -90,7 +90,7 @@ int
 main()
 {
   int i, j;
-  int result;
+  DWORD_PTR result;
   int serialThreadsTotal;
   pthread_t t[NUMTHREADS + 1];
 
@@ -112,7 +112,7 @@ main()
       for (i = 1; i <= j; i++)
         {
           assert(pthread_join(t[i], (void **) &result) == 0);
-          serialThreadsTotal += result;
+           serialThreadsTotal += (int)result;
         }
 
       assert(serialThreadsTotal == BARRIERS - 1);
Index: pthreads/tests/cancel8.c
===================================================================
--- pthreads.orig/tests/cancel8.c
+++ pthreads/tests/cancel8.c
@@ -195,7 +195,7 @@ main()
       assert(threadbag[i].self.p != NULL);
       assert(pthread_kill(threadbag[i].self, 0) == ESRCH);
 
-      fail = (result != (int) PTHREAD_CANCELED);
+      fail = (result != (int) (size_t) PTHREAD_CANCELED);
 
       if (fail)
 	{
Index: pthreads/tests/inherit1.c
===================================================================
--- pthreads.orig/tests/inherit1.c
+++ pthreads/tests/inherit1.c
@@ -89,7 +89,7 @@ void * func(void * arg)
   struct sched_param param;
 
   assert(pthread_getschedparam(pthread_self(), &policy, &param) == 0);
-  return (void *) param.sched_priority;
+  return (void *) (size_t) param.sched_priority;
 }
 
 
@@ -169,7 +169,7 @@ main()
           assert(pthread_attr_setschedparam(&attr, &param) == 0);
           assert(pthread_create(&t, &attr, func, NULL) == 0);
           pthread_join(t, &result);
-          assert((int) result == mainParam.sched_priority);
+          assert((int) (size_t)result == mainParam.sched_priority);
         }
     }
 
Index: pthreads/tests/priority1.c
===================================================================
--- pthreads.orig/tests/priority1.c
+++ pthreads/tests/priority1.c
@@ -91,7 +91,7 @@ func(void * arg)
 
   assert(pthread_getschedparam(threadID, &policy, &param) == 0);
   assert(policy == SCHED_OTHER);
-  return (void *) (param.sched_priority);
+  return (void *) (size_t) (param.sched_priority);
 }
 
 void *
@@ -164,8 +164,8 @@ main()
 
       assert(pthread_join(t, &result) == 0);
 
-      assert(param.sched_priority == (int) result);
-      printf("%10d %10d %10d\n", param.sched_priority, (int) result, prio);
+      assert(param.sched_priority == (int) (size_t) result);
+      printf("%10d %10d %10d\n", param.sched_priority, (int) (size_t) result, prio);
     }
 
   return 0;
Index: pthreads/tests/priority2.c
===================================================================
--- pthreads.orig/tests/priority2.c
+++ pthreads/tests/priority2.c
@@ -95,7 +95,7 @@ void * func(void * arg)
   assert(policy == SCHED_OTHER);
   result = pthread_barrier_wait(&endBarrier);
   assert(result == 0 || result == PTHREAD_BARRIER_SERIAL_THREAD);
-  return (void *) param.sched_priority;
+  return (void *) (size_t) param.sched_priority;
 }
 
 
@@ -162,7 +162,7 @@ main()
       assert(GetThreadPriority(pthread_getw32threadhandle_np(t)) ==
 	  validPriorities[param.sched_priority+(PTW32TEST_MAXPRIORITIES/2)]);
       pthread_join(t, &result);
-      assert(param.sched_priority == (int)result);
+      assert(param.sched_priority == (int)(size_t)result);
     }
 
   return 0;
Index: pthreads/tests/spin3.c
===================================================================
--- pthreads.orig/tests/spin3.c
+++ pthreads/tests/spin3.c
@@ -46,7 +46,7 @@ static pthread_spinlock_t spin;
  
 void * unlocker(void * arg)
 {
-  int expectedResult = (int) arg;
+  int expectedResult = (int) (size_t) arg;
 
   wasHere++;
   assert(pthread_spin_unlock(&spin) == expectedResult);
Index: pthreads/tests/stress1.c
===================================================================
--- pthreads.orig/tests/stress1.c
+++ pthreads/tests/stress1.c
@@ -1,278 +1,279 @@
-/*
- * stress1.c
- *
- *
- * --------------------------------------------------------------------------
- *
- *      Pthreads-win32 - POSIX Threads Library for Win32
- *      Copyright(C) 1998 John E. Bossom
- *      Copyright(C) 1999,2005 Pthreads-win32 contributors
- * 
- *      Contact Email: rpj@callisto.canberra.edu.au
- * 
- *      The current list of contributors is contained
- *      in the file CONTRIBUTORS included with the source
- *      code distribution. The list can also be seen at the
- *      following World Wide Web location:
- *      http://sources.redhat.com/pthreads-win32/contributors.html
- * 
- *      This library is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU Lesser General Public
- *      License as published by the Free Software Foundation; either
- *      version 2 of the License, or (at your option) any later version.
- * 
- *      This library is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *      Lesser General Public License for more details.
- * 
- *      You should have received a copy of the GNU Lesser General Public
- *      License along with this library in the file COPYING.LIB;
- *      if not, write to the Free Software Foundation, Inc.,
- *      59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
- *
- * --------------------------------------------------------------------------
- *
- * Test Synopsis:
- * - Stress test condition variables, mutexes, semaphores.
- *
- * Test Method (Validation or Falsification):
- * - Validation
- *
- * Requirements Tested:
- * - Correct accounting of semaphore and condition variable waiters.
- *
- * Features Tested:
- * - 
- *
- * Cases Tested:
- * - 
- *
- * Description:
- * Attempting to expose race conditions in cond vars, semaphores etc.
- * - Master attempts to signal slave close to when timeout is due.
- * - Master and slave do battle continuously until main tells them to stop.
- * - Afterwards, the CV must be successfully destroyed (will return an
- * error if there are waiters (including any internal semaphore waiters,
- * which, if there are, cannot not be real waiters).
- *
- * Environment:
- * - 
- *
- * Input:
- * - None.
- *
- * Output:
- * - File name, Line number, and failed expression on failure.
- * - No output on success.
- *
- * Assumptions:
- * - 
- *
- * Pass Criteria:
- * - CV is successfully destroyed.
- *
- * Fail Criteria:
- * - CV destroy fails.
- */
-
-#include "test.h"
-#include <string.h>
-#include <sys/timeb.h>
-
-
-const unsigned int ITERATIONS = 1000;
-
-static pthread_t master, slave;
-typedef struct {
-  int value;
-  pthread_cond_t cv;
-  pthread_mutex_t mx;
-} mysig_t;
-
-static int allExit;
-static mysig_t control = {0, PTHREAD_COND_INITIALIZER, PTHREAD_MUTEX_INITIALIZER};
-static pthread_barrier_t startBarrier, readyBarrier, holdBarrier;
-static int timeoutCount = 0;
-static int signalsTakenCount = 0;
-static int signalsSent = 0;
-static int bias = 0;
-static int timeout = 10; // Must be > 0
-
-enum {
-  CTL_STOP     = -1
-};
-
-/*
- * Returns abstime 'milliseconds' from 'now'.
- *
- * Works for: -INT_MAX <= millisecs <= INT_MAX
- */
-struct timespec *
-millisecondsFromNow (struct timespec * time, int millisecs)
-{
-  struct _timeb currSysTime;
-  int64_t nanosecs, secs;
-  const int64_t NANOSEC_PER_MILLISEC = 1000000;
-  const int64_t NANOSEC_PER_SEC = 1000000000;
-
-  /* get current system time and add millisecs */
-  _ftime(&currSysTime);
-
-  secs = (int64_t)(currSysTime.time) + (millisecs / 1000);
-  nanosecs = ((int64_t) (millisecs%1000 + currSysTime.millitm)) * NANOSEC_PER_MILLISEC;
-  if (nanosecs >= NANOSEC_PER_SEC)
-    {
-      secs++;
-      nanosecs -= NANOSEC_PER_SEC;
-    }
-  else if (nanosecs < 0)
-    {
-      secs--;
-      nanosecs += NANOSEC_PER_SEC;
-    }
-
-  time->tv_nsec = (long)nanosecs;
-  time->tv_sec = (long)secs;
-
-  return time;
-}
-
-void *
-masterThread (void * arg)
-{
-  int dither = (int) arg;
-
-  timeout = (int) arg;
-
-  pthread_barrier_wait(&startBarrier);
-
-  do
-    {
-      int sleepTime;
-
-      assert(pthread_mutex_lock(&control.mx) == 0);
-      control.value = timeout;
-      assert(pthread_mutex_unlock(&control.mx) == 0);
-
-      /*
-       * We are attempting to send the signal close to when the slave
-       * is due to timeout. We feel around by adding some [non-random] dither.
-       *
-       * dither is in the range 2*timeout peak-to-peak
-       * sleep time is the average of timeout plus dither.
-       * e.g.
-       * if timeout = 10 then dither = 20 and
-       * sleep millisecs is: 5 <= ms <= 15
-       *
-       * The bias value attempts to apply some negative feedback to keep
-       * the ratio of timeouts to signals taken close to 1:1.
-       * bias changes more slowly than dither so as to average more.
-       *
-       * Finally, if abs(bias) exceeds timeout then timeout is incremented.
-       */
-      if (signalsSent % timeout == 0)
-	{
-          if (timeoutCount > signalsTakenCount)
-	    {
-	      bias++;
-	    }
-          else if (timeoutCount < signalsTakenCount)
-	    {
-	      bias--;
-	    }
-	  if (bias < -timeout || bias > timeout)
-	    {
-	      timeout++;
-	    }
-	}
-      dither = (dither + 1 ) % (timeout * 2);
-      sleepTime = (timeout - bias + dither) / 2;
-      Sleep(sleepTime);
-      assert(pthread_cond_signal(&control.cv) == 0);
-      signalsSent++;
-
-      pthread_barrier_wait(&holdBarrier);
-      pthread_barrier_wait(&readyBarrier);
-    }
-  while (!allExit);
-
-  return NULL;
-}
-
-void *
-slaveThread (void * arg)
-{
-  struct timespec time;
-
-  pthread_barrier_wait(&startBarrier);
-
-  do
-    {
-      assert(pthread_mutex_lock(&control.mx) == 0);
-      if (pthread_cond_timedwait(&control.cv,
-				 &control.mx,
-				 millisecondsFromNow(&time, control.value)) == ETIMEDOUT)
-	{
-	  timeoutCount++;
-	}
-      else
-	{
-	  signalsTakenCount++;
-	}
-      assert(pthread_mutex_unlock(&control.mx) == 0);
-
-      pthread_barrier_wait(&holdBarrier);
-      pthread_barrier_wait(&readyBarrier);
-    }
-  while (!allExit);
-
-  return NULL;
-}
-
-int
-main ()
-{
-  unsigned int i;
-
-  assert(pthread_barrier_init(&startBarrier, NULL, 3) == 0);
-  assert(pthread_barrier_init(&readyBarrier, NULL, 3) == 0);
-  assert(pthread_barrier_init(&holdBarrier, NULL, 3) == 0);
-
-  assert(pthread_create(&master, NULL, masterThread, (void *) timeout) == 0);
-  assert(pthread_create(&slave, NULL, slaveThread, NULL) == 0);
-
-  allExit = FALSE;
-
-  pthread_barrier_wait(&startBarrier);
-
-  for (i = 1; !allExit; i++)
-    {
-      pthread_barrier_wait(&holdBarrier);
-      if (i >= ITERATIONS)
-	{
-	  allExit = TRUE;
-	}
-      pthread_barrier_wait(&readyBarrier);
-    }
-
-  assert(pthread_join(slave, NULL) == 0);
-  assert(pthread_join(master, NULL) == 0);
-
-  printf("Signals sent = %d\nWait timeouts = %d\nSignals taken = %d\nBias = %d\nTimeout = %d\n",
-	 signalsSent,
-	 timeoutCount,
-	 signalsTakenCount,
-	 (int) bias,
-	 timeout);
-
-  /* Cleanup */
-  assert(pthread_barrier_destroy(&holdBarrier) == 0);
-  assert(pthread_barrier_destroy(&readyBarrier) == 0);
-  assert(pthread_barrier_destroy(&startBarrier) == 0);
-  assert(pthread_cond_destroy(&control.cv) == 0);
-  assert(pthread_mutex_destroy(&control.mx) == 0);
-
-  /* Success. */
-  return 0;
-}
+/*
+ * stress1.c
+ *
+ *
+ * --------------------------------------------------------------------------
+ *
+ *      Pthreads-win32 - POSIX Threads Library for Win32
+ *      Copyright(C) 1998 John E. Bossom
+ *      Copyright(C) 1999,2005 Pthreads-win32 contributors
+ * 
+ *      Contact Email: rpj@callisto.canberra.edu.au
+ * 
+ *      The current list of contributors is contained
+ *      in the file CONTRIBUTORS included with the source
+ *      code distribution. The list can also be seen at the
+ *      following World Wide Web location:
+ *      http://sources.redhat.com/pthreads-win32/contributors.html
+ * 
+ *      This library is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU Lesser General Public
+ *      License as published by the Free Software Foundation; either
+ *      version 2 of the License, or (at your option) any later version.
+ * 
+ *      This library is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *      Lesser General Public License for more details.
+ * 
+ *      You should have received a copy of the GNU Lesser General Public
+ *      License along with this library in the file COPYING.LIB;
+ *      if not, write to the Free Software Foundation, Inc.,
+ *      59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ *
+ * --------------------------------------------------------------------------
+ *
+ * Test Synopsis:
+ * - Stress test condition variables, mutexes, semaphores.
+ *
+ * Test Method (Validation or Falsification):
+ * - Validation
+ *
+ * Requirements Tested:
+ * - Correct accounting of semaphore and condition variable waiters.
+ *
+ * Features Tested:
+ * - 
+ *
+ * Cases Tested:
+ * - 
+ *
+ * Description:
+ * Attempting to expose race conditions in cond vars, semaphores etc.
+ * - Master attempts to signal slave close to when timeout is due.
+ * - Master and slave do battle continuously until main tells them to stop.
+ * - Afterwards, the CV must be successfully destroyed (will return an
+ * error if there are waiters (including any internal semaphore waiters,
+ * which, if there are, cannot not be real waiters).
+ *
+ * Environment:
+ * - 
+ *
+ * Input:
+ * - None.
+ *
+ * Output:
+ * - File name, Line number, and failed expression on failure.
+ * - No output on success.
+ *
+ * Assumptions:
+ * - 
+ *
+ * Pass Criteria:
+ * - CV is successfully destroyed.
+ *
+ * Fail Criteria:
+ * - CV destroy fails.
+ */
+
+#include "test.h"
+#include <string.h>
+#include <sys/timeb.h>
+
+
+const unsigned int ITERATIONS = 1000;
+
+static pthread_t master, slave;
+typedef struct {
+  int value;
+  pthread_cond_t cv;
+  pthread_mutex_t mx;
+} mysig_t;
+
+static int allExit;
+static mysig_t control = {0, PTHREAD_COND_INITIALIZER, PTHREAD_MUTEX_INITIALIZER};
+static pthread_barrier_t startBarrier, readyBarrier, holdBarrier;
+static int timeoutCount = 0;
+static int signalsTakenCount = 0;
+static int signalsSent = 0;
+static int bias = 0;
+static int timeout = 10;
+ // Must be > 0
+
+enum {
+  CTL_STOP     = -1
+};
+
+/*
+ * Returns abstime 'milliseconds' from 'now'.
+ *
+ * Works for: -INT_MAX <= millisecs <= INT_MAX
+ */
+struct timespec *
+millisecondsFromNow (struct timespec * time, int millisecs)
+{
+  struct _timeb currSysTime;
+  int64_t nanosecs, secs;
+  const int64_t NANOSEC_PER_MILLISEC = 1000000;
+  const int64_t NANOSEC_PER_SEC = 1000000000;
+
+  /* get current system time and add millisecs */
+  _ftime(&currSysTime);
+
+  secs = (int64_t)(currSysTime.time) + (millisecs / 1000);
+  nanosecs = ((int64_t) (millisecs%1000 + currSysTime.millitm)) * NANOSEC_PER_MILLISEC;
+  if (nanosecs >= NANOSEC_PER_SEC)
+    {
+      secs++;
+      nanosecs -= NANOSEC_PER_SEC;
+    }
+  else if (nanosecs < 0)
+    {
+      secs--;
+      nanosecs += NANOSEC_PER_SEC;
+    }
+
+  time->tv_nsec = (long)nanosecs;
+  time->tv_sec = (long)secs;
+
+  return time;
+}
+
+void *
+masterThread (void * arg)
+{
+  int dither = (int) (size_t)arg;
+
+  timeout = (int) (size_t)arg;
+
+  pthread_barrier_wait(&startBarrier);
+
+  do
+    {
+      int sleepTime;
+
+      assert(pthread_mutex_lock(&control.mx) == 0);
+      control.value = timeout;
+      assert(pthread_mutex_unlock(&control.mx) == 0);
+
+      /*
+       * We are attempting to send the signal close to when the slave
+       * is due to timeout. We feel around by adding some [non-random] dither.
+       *
+       * dither is in the range 2*timeout peak-to-peak
+       * sleep time is the average of timeout plus dither.
+       * e.g.
+       * if timeout = 10 then dither = 20 and
+       * sleep millisecs is: 5 <= ms <= 15
+       *
+       * The bias value attempts to apply some negative feedback to keep
+       * the ratio of timeouts to signals taken close to 1:1.
+       * bias changes more slowly than dither so as to average more.
+       *
+       * Finally, if abs(bias) exceeds timeout then timeout is incremented.
+       */
+      if (signalsSent % timeout == 0)
+	{
+          if (timeoutCount > signalsTakenCount)
+	    {
+	      bias++;
+	    }
+          else if (timeoutCount < signalsTakenCount)
+	    {
+	      bias--;
+	    }
+	  if (bias < -timeout || bias > timeout)
+	    {
+	      timeout++;
+	    }
+	}
+      dither = (dither + 1 ) % (timeout * 2);
+      sleepTime = (timeout - bias + dither) / 2;
+      Sleep(sleepTime);
+      assert(pthread_cond_signal(&control.cv) == 0);
+      signalsSent++;
+
+      pthread_barrier_wait(&holdBarrier);
+      pthread_barrier_wait(&readyBarrier);
+    }
+  while (!allExit);
+
+  return NULL;
+}
+
+void *
+slaveThread (void * arg)
+{
+  struct timespec time;
+
+  pthread_barrier_wait(&startBarrier);
+
+  do
+    {
+      assert(pthread_mutex_lock(&control.mx) == 0);
+      if (pthread_cond_timedwait(&control.cv,
+				 &control.mx,
+				 millisecondsFromNow(&time, control.value)) == ETIMEDOUT)
+	{
+	  timeoutCount++;
+	}
+      else
+	{
+	  signalsTakenCount++;
+	}
+      assert(pthread_mutex_unlock(&control.mx) == 0);
+
+      pthread_barrier_wait(&holdBarrier);
+      pthread_barrier_wait(&readyBarrier);
+    }
+  while (!allExit);
+
+  return NULL;
+}
+
+int
+main ()
+{
+  unsigned int i;
+
+  assert(pthread_barrier_init(&startBarrier, NULL, 3) == 0);
+  assert(pthread_barrier_init(&readyBarrier, NULL, 3) == 0);
+  assert(pthread_barrier_init(&holdBarrier, NULL, 3) == 0);
+
+  assert(pthread_create(&master, NULL, masterThread, (void *) (size_t)timeout) == 0);
+  assert(pthread_create(&slave, NULL, slaveThread, NULL) == 0);
+
+  allExit = FALSE;
+
+  pthread_barrier_wait(&startBarrier);
+
+  for (i = 1; !allExit; i++)
+    {
+      pthread_barrier_wait(&holdBarrier);
+      if (i >= ITERATIONS)
+	{
+	  allExit = TRUE;
+	}
+      pthread_barrier_wait(&readyBarrier);
+    }
+
+  assert(pthread_join(slave, NULL) == 0);
+  assert(pthread_join(master, NULL) == 0);
+
+  printf("Signals sent = %d\nWait timeouts = %d\nSignals taken = %d\nBias = %d\nTimeout = %d\n",
+	 signalsSent,
+	 timeoutCount,
+	 signalsTakenCount,
+	 (int) bias,
+	 timeout);
+
+  /* Cleanup */
+  assert(pthread_barrier_destroy(&holdBarrier) == 0);
+  assert(pthread_barrier_destroy(&readyBarrier) == 0);
+  assert(pthread_barrier_destroy(&startBarrier) == 0);
+  assert(pthread_cond_destroy(&control.cv) == 0);
+  assert(pthread_mutex_destroy(&control.mx) == 0);
+
+  /* Success. */
+  return 0;
+}
